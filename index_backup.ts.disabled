// index.ts - Alpha Snipes Bot with Jito-lite Priority & Rug Checks
import 'dotenv/config';
import { Connection, PublicKey, Keypair, VersionedTransaction } from '@solana/web3.js';
import bs58 from 'bs58';
import fetch from 'node-fetch';
import { basicRugChecks } from './lib/rug_checks.js';
import { priorityIxs } from './lib/priority.js';

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Configuration
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Trading Mode
const TRADE_MODE = (process.env.TRADE_MODE || 'paper').toLowerCase(); // 'paper' or 'live'
const IS_PAPER = TRADE_MODE !== 'live';

const RPC_URL = process.env.SOLANA_RPC_URL || 'https://api.mainnet-beta.solana.com';
const TELEGRAM_TOKEN = process.env.TELEGRAM_TOKEN!;
const TELEGRAM_CHAT_ID = process.env.TELEGRAM_CHAT_ID!;
const ALPHA_WALLET = process.env.ALPHA_WALLET!;
const BUY_SOL = parseFloat(process.env.BUY_SOL || '0.01');
const EARLY_TP_PCT = parseFloat(process.env.EARLY_TP_PCT || '0.3');
const TRAIL_STOP_PCT = parseFloat(process.env.TRAIL_STOP_PCT || '0.2');

// Priority fee (Jito-lite)
const CU_UNIT_PRICE = parseInt(process.env.CU_UNIT_PRICE_MICROLAMPORTS || '5000', 10);
const CU_LIMIT = parseInt(process.env.CU_LIMIT || '800000', 10);

// Rug checks
const REQUIRE_AUTH_REVOKED = (process.env.REQUIRE_AUTHORITY_REVOKED || 'true') === 'true';
const MAX_TAX_BPS = parseInt(process.env.MAX_TAX_BPS || '500', 10);
const MAX_PRICE_IMPACT_BPS = parseInt(process.env.MAX_PRICE_IMPACT_BPS || '3000', 10);
const SENTRY_WINDOW_SEC = parseInt(process.env.SENTRY_WINDOW_SEC || '120', 10);
const SENTRY_MAX_DD = parseFloat(process.env.SENTRY_MAX_DRAWDOWN_PCT || '0.22');

// Wallet
let walletKeypair: Keypair;
if (IS_PAPER) {
  // Paper mode: use dummy keypair (never broadcasts)
  walletKeypair = Keypair.generate();
  console.log('ğŸ“„ PAPER MODE: No real transactions will be sent');
} else {
  // Live mode: require valid private key
  try {
    const privKey = process.env.WALLET_PRIVATE_KEY || '';
    if (!privKey) {
      throw new Error('WALLET_PRIVATE_KEY required for live mode');
    }
    walletKeypair = Keypair.fromSecretKey(bs58.decode(privKey));
  } catch (err: any) {
    console.error('âŒ Invalid WALLET_PRIVATE_KEY in .env:', err.message);
    process.exit(1);
  }
}

// Connection
const connection = new Connection(RPC_URL, 'confirmed');

// State
const seenMints = new Set<string>();
const openPositions: Record<
  string,
  {
    mint: PublicKey;
    qty: bigint;
    costSol: number;
    entryPrice: number;
    highPrice: number;
  }
> = {};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Telegram Alert
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function alert(text: string) {
  // Add [PAPER] tag in paper mode
  const tag = IS_PAPER ? '[PAPER] ' : '';
  const fullText = text.startsWith('[PAPER]') ? text : `${tag}${text}`;
  
  try {
    const url = `https://api.telegram.org/bot${TELEGRAM_TOKEN}/sendMessage`;
    const res = await fetch(url, {
      method: 'POST',
      headers: { 'content-type': 'application/x-www-form-urlencoded' },
      body: new URLSearchParams({
        chat_id: TELEGRAM_CHAT_ID,
        text: fullText,
        parse_mode: 'HTML',
        disable_web_page_preview: 'true',
      }),
    });
    const data = await res.json();
    if (!data.ok) {
      console.error('Telegram error:', data);
    }
  } catch (err: any) {
    console.error('Alert failed:', err.message || err);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Jupiter V6 API Helpers
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function getJupiterQuote(
  inputMint: string,
  outputMint: string,
  amount: number,
  slippageBps: number = 50
): Promise<any> {
  const url = `https://quote-api.jup.ag/v6/quote?inputMint=${inputMint}&outputMint=${outputMint}&amount=${amount}&slippageBps=${slippageBps}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error(`Jupiter quote failed: ${res.statusText}`);
  return await res.json();
}

async function getJupiterSwapTransaction(quoteResponse: any): Promise<string> {
  const url = 'https://quote-api.jup.ag/v6/swap';
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      quoteResponse,
      userPublicKey: walletKeypair.publicKey.toBase58(),
      wrapAndUnwrapSol: true,
      dynamicComputeUnitLimit: true,
      priorityLevelWithMaxLamports: {
        maxLamports: CU_LIMIT * CU_UNIT_PRICE,
      },
    }),
  });
  if (!res.ok) throw new Error(`Jupiter swap failed: ${res.statusText}`);
  const { swapTransaction } = await res.json();
  return swapTransaction;
}

async function executeSwap(serializedTx: string): Promise<string> {
  const txBuf = Buffer.from(serializedTx, 'base64');
  const tx = VersionedTransaction.deserialize(txBuf);
  tx.sign([walletKeypair]);

  const sig = await connection.sendTransaction(tx, {
    skipPreflight: false,
    maxRetries: 3,
  });

  await connection.confirmTransaction(sig, 'confirmed');
  return sig;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Paper Trading Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

type PaperExec = { txid: string; outAmount: string; solOutLamports?: number };

async function paperBuy(mint: PublicKey, solAmount: number): Promise<PaperExec> {
  const SOL = 'So11111111111111111111111111111111111111112';
  const lamports = Math.floor(solAmount * 1e9);

  const quote = await getJupiterQuote(SOL, mint.toBase58(), lamports, 300);
  if (!quote || !quote.outAmount) {
    throw new Error('No route found (paper mode)');
  }

  // Simulate execution using quote (no actual transaction)
  return { txid: '[PAPER-BUY]', outAmount: quote.outAmount };
}

async function paperSell(mint: PublicKey, tokenAmount: bigint): Promise<PaperExec> {
  const SOL = 'So11111111111111111111111111111111111111112';
  const quote = await getJupiterQuote(mint.toBase58(), SOL, Number(tokenAmount), 300);
  if (!quote || !quote.outAmount) {
    throw new Error('No sell route found (paper mode)');
  }

  // Simulate execution using quote (no actual transaction)
  return { txid: '[PAPER-SELL]', outAmount: '0', solOutLamports: Number(quote.outAmount) };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Live Trading Functions
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function liveSwapSOLforToken(
  mint: PublicKey,
  solAmount: number
): Promise<{ txid: string; outAmount: string }> {
  const SOL = 'So11111111111111111111111111111111111111112';
  const lamports = Math.floor(solAmount * 1e9);

  const quote = await getJupiterQuote(SOL, mint.toBase58(), lamports, 300);
  const swapTx = await getJupiterSwapTransaction(quote);
  const txid = await executeSwap(swapTx);

  return { txid, outAmount: quote.outAmount };
}

async function liveSwapTokenForSOL(mint: PublicKey, tokenAmount: bigint): Promise<{ txid: string }> {
  const SOL = 'So11111111111111111111111111111111111111112';
  const quote = await getJupiterQuote(mint.toBase58(), SOL, Number(tokenAmount), 300);
  const swapTx = await getJupiterSwapTransaction(quote);
  const txid = await executeSwap(swapTx);

  return { txid };
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Swap Functions (Branch on Mode)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function swapSOLforToken(
  mint: PublicKey,
  solAmount: number
): Promise<{ txid: string; outAmount: string }> {
  if (IS_PAPER) {
    return await paperBuy(mint, solAmount);
  } else {
    return await liveSwapSOLforToken(mint, solAmount);
  }
}

async function swapTokenForSOL(mint: PublicKey, tokenAmount: bigint): Promise<{ txid: string; solOutLamports?: number }> {
  if (IS_PAPER) {
    return await paperSell(mint, tokenAmount);
  } else {
    return await liveSwapTokenForSOL(mint, tokenAmount);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Price Monitoring
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function getQuotePrice(mint: PublicKey): Promise<number | null> {
  try {
    const SOL = 'So11111111111111111111111111111111111111112';
    const quote = await getJupiterQuote(mint.toBase58(), SOL, 1_000_000, 1000);
    if (!quote || !quote.outAmount) return null;
    const solOut = Number(quote.outAmount) / 1e9;
    if (solOut <= 0) return null;
    return solOut / 0.001; // price per token in SOL
  } catch {
    return null;
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Paper Trading PnL Reporting
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function toSol(lamports: number): number {
  return lamports / 1e9;
}

async function reportPaperPnL(mintStr: string, entrySol: number, exitSolLamports: number) {
  const exitSol = toSol(exitSolLamports);
  const pnl = exitSol - entrySol;
  const pct = (pnl / entrySol) * 100;
  const emoji = pnl >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';
  
  await alert(
    `${emoji} PnL for <code>${mintStr.slice(0, 8)}...</code>\n` +
    `Entry: ${entrySol.toFixed(4)} SOL\n` +
    `Exit: ${exitSol.toFixed(4)} SOL\n` +
    `Profit: ${pnl >= 0 ? '+' : ''}${pnl.toFixed(4)} SOL (${pct >= 0 ? '+' : ''}${pct.toFixed(1)}%)`
  );
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Alpha Wallet Watcher
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function watchAlphaWallet() {
  const alphaPk = new PublicKey(ALPHA_WALLET);
  let lastSig = '';

  while (true) {
    try {
      const sigs = await connection.getSignaturesForAddress(alphaPk, { limit: 1 });
      if (sigs.length > 0 && sigs[0].signature !== lastSig) {
        lastSig = sigs[0].signature;
        await handleAlphaTx(sigs[0].signature);
      }
    } catch (err: any) {
      console.error('Watch error:', err.message || err);
    }
    await new Promise((r) => setTimeout(r, 3000));
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Transaction Handler with Rug Checks
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function handleAlphaTx(sig: string) {
  const tx = await connection.getParsedTransaction(sig, {
    maxSupportedTransactionVersion: 0,
  });
  if (!tx || !tx.meta) return;

  // Extract new mints from transaction
  const mints = extractMints(tx);
  if (mints.length === 0) return;

  for (const m of mints) {
    if (seenMints.has(m)) continue;
    seenMints.add(m);

    const mintPk = new PublicKey(m);
    await alert(`ğŸ‘€ Alpha touched new mint <code>${m}</code>\nTX: <code>${sig}</code>`);

    try {
      // Run rug checks
      const report = await basicRugChecks(connection, mintPk, BUY_SOL, {
        requireAuthorityRevoked: REQUIRE_AUTH_REVOKED,
        maxTaxBps: MAX_TAX_BPS,
        maxImpactBps: MAX_PRICE_IMPACT_BPS,
      });

      if (!report.ok) {
        await alert(`â›”ï¸ Skipping <code>${m}</code> due to: ${report.reasons.join(', ')}`);
        continue;
      }

      // Checks passed - execute buy
      const start = report.entryPrice ?? (await getQuotePrice(mintPk)) ?? 0;
      const buy = await swapSOLforToken(mintPk, BUY_SOL);
      const qty = BigInt(buy.outAmount);

      openPositions[m] = {
        mint: mintPk,
        qty,
        costSol: BUY_SOL,
        entryPrice: start,
        highPrice: start,
      };

      await alert(
        [
          `âœ… Bought ${BUY_SOL.toFixed(3)} SOL of <code>${m}</code> (checks passed)`,
          `TX: https://solscan.io/tx/${buy.txid}`,
          start ? `Ref price ~ ${start.toFixed(10)} SOL/token` : '',
        ]
          .filter(Boolean)
          .join('\n')
      );

      // Start sentry + exit manager
      Promise.all([manageExit(m), postBuySentry(m)]).catch(() => {});
    } catch (e: any) {
      await alert(`âŒ Buy failed for ${m}: ${e.message || e}`);
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Exit Manager (Early TP + Trailing Stop)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function manageExit(mintStr: string) {
  const pos = openPositions[mintStr];
  if (!pos) return;

  const earlyTarget = pos.entryPrice * (1 + EARLY_TP_PCT);
  let phase: 'early' | 'trailing' = 'early';

  while (openPositions[mintStr]) {
    await new Promise((r) => setTimeout(r, 5000));
    const price = await getQuotePrice(pos.mint);
    if (!price) continue;

    if (price > pos.highPrice) pos.highPrice = price;

    if (phase === 'early' && price >= earlyTarget) {
      // Early TP triggered - sell portion or all
      phase = 'trailing';
      await alert(
        `ğŸ¯ Early TP hit for ${mintStr}: ${price.toFixed(10)} SOL (target ${earlyTarget.toFixed(
          10
        )})\nSwitching to trailing stop...`
      );
    }

    if (phase === 'trailing') {
      const trailTrigger = pos.highPrice * (1 - TRAIL_STOP_PCT);
      if (price <= trailTrigger) {
        // Trailing stop triggered
        try {
          const tx = await swapTokenForSOL(pos.mint, pos.qty);
          const pnl = ((price - pos.entryPrice) / pos.entryPrice) * 100;
          await alert(
            `ğŸ›‘ Trailing stop exit: ${mintStr}\nPrice: ${price.toFixed(
              10
            )} SOL\nPnL: ${pnl.toFixed(1)}%\nTX: https://solscan.io/tx/${tx.txid}`
          );
          
          // Report paper PnL if in paper mode
          if (IS_PAPER && tx.solOutLamports) {
            await reportPaperPnL(mintStr, pos.costSol, tx.solOutLamports);
          }
          
          delete openPositions[mintStr];
          return;
        } catch (err: any) {
          await alert(`âŒ Exit failed for ${mintStr}: ${err.message || err}`);
        }
      }
    }
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Post-Buy Sentry (Early Drawdown Monitor)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function postBuySentry(mintStr: string) {
  const pos = openPositions[mintStr];
  if (!pos) return;
  const entry = pos.entryPrice || 0;
  const start = Date.now();

  await alert(`ğŸ›¡ï¸ Sentry monitoring ${mintStr} for ${SENTRY_WINDOW_SEC}s...`);

  while ((Date.now() - start) / 1000 < SENTRY_WINDOW_SEC) {
    await new Promise((r) => setTimeout(r, 4000));
    if (!openPositions[mintStr]) return; // Already exited

    const price = await getQuotePrice(pos.mint);
    if (!price || entry === 0) continue;

    const dd = (entry - price) / entry;
    if (dd >= SENTRY_MAX_DD) {
      // Emergency exit
      try {
        const tx = await swapTokenForSOL(pos.mint, pos.qty);
        await alert(
          `ğŸš¨ Sentry abort: drawdown ${(dd * 100).toFixed(
            1
          )}% reached.\nTX: https://solscan.io/tx/${tx.txid}`
        );
        
        // Report paper PnL if in paper mode
        if (IS_PAPER && tx.solOutLamports) {
          await reportPaperPnL(mintStr, pos.costSol, tx.solOutLamports);
        }
        
        delete openPositions[mintStr];
        return;
      } catch (err: any) {
        await alert(`âŒ Sentry exit failed for ${mintStr}: ${err.message || err}`);
      }
    }
  }

  if (openPositions[mintStr]) {
    await alert(`ğŸ›¡ï¸ Sentry window ended for ${mintStr} - no issues detected`);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Mint Extraction Helper
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function extractMints(tx: any): string[] {
  const mints: string[] = [];
  const SOL = 'So11111111111111111111111111111111111111112';

  try {
    const preBalances = tx.meta?.preTokenBalances || [];
    const postBalances = tx.meta?.postTokenBalances || [];

    for (const post of postBalances) {
      const mint = post.mint;
      if (mint === SOL) continue;
      const pre = preBalances.find((p: any) => p.mint === mint);
      if (!pre || Number(post.uiTokenAmount.uiAmount) > Number(pre.uiTokenAmount.uiAmount)) {
        mints.push(mint);
      }
    }
  } catch {
    // Ignore extraction errors
  }

  return mints;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// Main Entry
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function main() {
  const mode = IS_PAPER ? 'ğŸ“„ PAPER MODE' : 'ğŸ’° LIVE MODE';
  console.log(`ğŸš€ Alpha Snipes Bot Starting... ${mode}`);
  console.log(`ğŸ“ Wallet: ${walletKeypair.publicKey.toBase58()}`);
  console.log(`ğŸ‘€ Watching: ${ALPHA_WALLET}`);
  console.log(`ğŸ’° Buy size: ${BUY_SOL} SOL`);
  console.log(`ğŸ¯ Early TP: ${EARLY_TP_PCT * 100}%`);
  console.log(`ğŸ›‘ Trailing stop: ${TRAIL_STOP_PCT * 100}%`);
  console.log(`ğŸ›¡ï¸ Sentry window: ${SENTRY_WINDOW_SEC}s (max DD: ${SENTRY_MAX_DD * 100}%)`);
  console.log(`âš™ï¸  Priority: ${CU_UNIT_PRICE} microLamports, ${CU_LIMIT} CU limit`);
  
  if (IS_PAPER) {
    console.log('');
    console.log('âš ï¸  PAPER MODE ACTIVE - No real transactions will be sent!');
    console.log('   All trades are simulated using live Jupiter quotes.');
    console.log('   Set TRADE_MODE=live in .env to enable real trading.');
    console.log('');
  }

  await alert(
    [
      `ğŸš€ <b>Alpha Snipes Bot Started</b> ${IS_PAPER ? '(PAPER MODE)' : '(LIVE)'}`,
      `Wallet: <code>${walletKeypair.publicKey.toBase58()}</code>`,
      `Watching: <code>${ALPHA_WALLET}</code>`,
      `Buy: ${BUY_SOL} SOL | TP: ${EARLY_TP_PCT * 100}% | Trail: ${TRAIL_STOP_PCT * 100}%`,
      `Sentry: ${SENTRY_WINDOW_SEC}s (DD: ${SENTRY_MAX_DD * 100}%)`,
    ].join('\n')
  );

  watchAlphaWallet();
}

main().catch((err) => {
  console.error('Fatal error:', err);
  process.exit(1);
});

